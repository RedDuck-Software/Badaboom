@inject Microsoft.Extensions.Configuration.IConfiguration config;
@using Badaboom.Core.Models.Enums
@using Badaboom.Core.Models.Request
@using System.Text.Json
@using System.Numerics 

<div class="modal @ModalClass" tabindex="-1" role="dialog" style="display:@ModalDisplay">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="staticBackdropLabel">Modal title</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close" @onclick="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body">

                <form class="form-inline">
                    <div class="d-flex col-7">Quantity of requests</div>
                    <label class="col">@(Nethereum.Web3.Web3.Convert.FromWei(ProductPrice.PricePerItem)) Eth per item</label>
                </form>
                <input type="range" class="mr-2" style="width:100%" min="1" max="1000" @bind="@QuantityForBuy" />
                <input type="number" min="1" max="1000" @bind="@QuantityForBuy" />
                <label> * @(Nethereum.Web3.Web3.Convert.FromWei(ProductPrice.PricePerItem)) = @(Nethereum.Web3.Web3.Convert.FromWei(TotalPrice)) Eth (Discount - @CurrentDiscount%)</label> 
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-dismiss="modal" @onclick="Close">Close</button>
                <button type="button" class="btn btn-primary" @onclick="Buy">Save changes</button>
            </div>
        </div>
    </div>
</div>

@if (ShowBackdrop)
{
    <div class="modal-backdrop fade show"></div>
}



@code {
    public string ModalDisplay = "none;";
    public string ModalClass = "";
    public bool ShowBackdrop = false;

    [Parameter]
    public Filtration Filtration { get; set; }

    private int quantityForBuy = 1;

    public int QuantityForBuy
    {
        get => quantityForBuy;

        set
        {
            quantityForBuy = value;
            CountTotalPrice();
            StateHasChanged();
        }
    }

    public byte CurrentDiscount { get; set; }

    public ProductPriceResponse ProductPrice { get; set; } = new ProductPriceResponse();

    public BigInteger TotalPrice { get; set; }

    public IOrderedEnumerable<KeyValuePair<int, byte>> SortedDiscounts { get; set; }

    public int Quantity
    {
        get
        {
            if (Filtration._authService.User != null && Filtration._authService.User.AvailableProduct.ContainsKey(ProductType.ArgumentFunctionRequests.ToString()))
            {
                return Filtration._authService.User.AvailableProduct[ProductType.ArgumentFunctionRequests.ToString()];
            }
            else
            {
                return default;
            }
        }
    }


    public async Task Open()
    {
        Filtration.Index.Loading = false;

        var response = await Filtration._httpService.Get($"/api/Payment/productPrice?ProductType={ProductType.ArgumentFunctionRequests}");
        ProductPrice = JsonSerializer.Deserialize<ProductPriceResponse>(response,
            new JsonSerializerOptions() { PropertyNameCaseInsensitive = true });
        TotalPrice = ProductPrice.PricePerItem;
        var sorted = ProductPrice.AmountFromPercents.OrderByDescending(x => x.Key);


        ModalDisplay = "block;";
        ModalClass = "Show";
        ShowBackdrop = true;
        StateHasChanged();
    }

    public async Task Close()
    {
        ModalDisplay = "none";
        ModalClass = "";
        ShowBackdrop = false;
        StateHasChanged();
    }

    public async Task Buy()
    {
        Filtration.Index.Loading = true;

        StateHasChanged();

        string toAddress = (await Filtration._httpService.Get<WalletAddress>("/api/Payment/walletAddressToSend")).walletAddress; // generate ex if auth token ends

        System.Numerics.BigInteger weiValue = TotalPrice;

        string txnHash;

        try
        {
            txnHash = await Filtration.MetaMaskService.SendTransaction(toAddress, weiValue);

            if (await CheckIsSuccessTransaction(txnHash))
            {
                Console.WriteLine("(Transaction status code success)");

                await Filtration._httpService.Post<PurchaseRequest>("/api/payment/purchase", new PurchaseRequest()
                {
                    ProductType = ProductType.ArgumentFunctionRequests,
                    Quantity = QuantityForBuy,
                    TxnHash = txnHash
                });

                if (Filtration._authService.User.AvailableProduct.ContainsKey(ProductType.ArgumentFunctionRequests.ToString()))
                {
                    Filtration._authService.User.AvailableProduct[ProductType.ArgumentFunctionRequests.ToString()] += QuantityForBuy;
                }
                else
                {
                    Filtration._authService.User.AvailableProduct.Add(ProductType.ArgumentFunctionRequests.ToString(), QuantityForBuy);
                }

                await Filtration._localStorageService.SetItem("user", Filtration._authService.User);
            }
            else
            {
                Console.WriteLine("(There is something wrong with your transaction)");
                Filtration.Index.Loading = false;
                return;
            }
        }
        catch (MetaMask.Blazor.Exceptions.UserDeniedException)
        {
            System.Console.WriteLine($"User Denied");
            Filtration.Index.Loading = false;
            return;
        }

        System.Console.WriteLine($"TX Hash: {txnHash}");

        await Close();
    }

    private async Task<bool> CheckIsSuccessTransaction(string txnHash)
    {
        int maxCycle = 18 * 2;
        int cycle = 0;
        Console.WriteLine($"Wait between 5 and 180 seconds, we check your transaction");
        while (cycle < maxCycle)
        {
            Nethereum.Web3.Web3 web3 = new(config.GetSection("RPCUrls")["EthRopsten"]);
            var transaction = await web3.Eth.Transactions.GetTransactionReceipt.SendRequestAsync(txnHash);

            await Task.Delay(5_000);

            try
            {
                if (transaction.Status.Value == 1)
                {
                    return true;
                }
            }
            catch (NullReferenceException)
            {
                Console.WriteLine("(Pending)");
            }

            cycle++;
        }

        return false;
    }

    private class WalletAddress
    {
        public string walletAddress { get; set; }
    }

    private class ResponseQuantity
    {
        public int? Quantity { get; set; }
    }

    public void CountTotalPrice()
    {
        var sorted = ProductPrice.AmountFromPercents.OrderByDescending(x => x.Key);

        foreach (var item in sorted)
        {
            if (QuantityForBuy >= item.Key)
            {
                TotalPrice = (BigInteger)ProductPrice.PricePerItem * QuantityForBuy * item.Value / 100;

                CurrentDiscount = (byte)(100 - item.Value);

                return;
            }
        }

        CurrentDiscount = 0;

        TotalPrice = ProductPrice.PricePerItem * QuantityForBuy;
    }
}